const std = @import("std");
const testing = std.testing;
const Ast = std.zig.Ast;

const analysis = @import("analysis.zig");

pub fn generateFiles(
    allocator: std.mem.Allocator,
    bindings_path: []const u8,
    generated_sysjs_zig: []const u8,
    generated_sysjs_js: []const u8,
) !void {
    var generated_zig = try std.fs.cwd().createFile(generated_sysjs_zig, .{});
    var generated_js = try std.fs.cwd().createFile(generated_sysjs_js, .{});
    var bindings_code = try std.fs.cwd().readFileAllocOptions(allocator, bindings_path, 1024 * 1024 * 128, null, @alignOf(u8), 0);
    defer allocator.free(bindings_code);

    const zig_writer = generated_zig.writer();
    const js_writer = generated_js.writer();
    var gen = Generator(@TypeOf(zig_writer), @TypeOf(js_writer)){
        .zig = zig_writer,
        .js = js_writer,
        .allocator = allocator,
        .bindings_code = bindings_code,
    };
    try gen.root();

    generated_zig.close();
    generated_js.close();
}

fn Generator(comptime ZigWriter: type, comptime JSWriter: type) type {
    return struct {
        zig: ZigWriter,
        js: JSWriter,
        allocator: std.mem.Allocator,
        bindings_code: [:0]const u8,

        // internal fields
        tree: Ast = undefined,
        buf: [4096]u8 = undefined,
        namespace: std.ArrayListUnmanaged([]const u8) = .{},

        pub fn root(gen: *@This()) !void {
            gen.tree = try Ast.parse(gen.allocator, gen.bindings_code, .zig);
            defer gen.tree.deinit(gen.allocator);

            try std.fmt.format(gen.zig, "// Generated by `zig build`; DO NOT EDIT.\n\n", .{});
            try std.fmt.format(gen.js, "// Generated by `zig build`; DO NOT EDIT.\n\n", .{});

            try gen.container(0);
        }

        pub fn container(gen: *@This(), node_idx: Ast.Node.Index) !void {
            var buf: [2]Ast.Node.Index = undefined;
            const container_decl = gen.tree.fullContainerDecl(&buf, node_idx) orelse return;
            for (container_decl.ast.members) |decl_idx| {
                const name_token = analysis.getDeclNameToken(gen.tree, decl_idx) orelse continue;
                const name = gen.tree.tokenSlice(name_token);

                // If this decl is a `pub const foo = struct {};` then consume it
                if (gen.tree.fullVarDecl(decl_idx)) |var_decl| {
                    // var/const
                    if (var_decl.visib_token) |visib_token| {
                        const visib = gen.tree.tokenSlice(visib_token);
                        if (std.mem.eql(u8, visib, "pub")) {
                            // pub var/const
                            const init_node = gen.tree.nodes.get(var_decl.ast.init_node);
                            switch (init_node.tag) {
                                .container_decl_two_trailing => {
                                    try gen.namespace.append(gen.allocator, name);
                                    try gen.container(var_decl.ast.init_node);
                                    continue;
                                },
                                else => {},
                            }
                        }
                    }
                }

                // If this decl is a struct field `foo: fn () void,` then consume it.
                if (gen.tree.fullContainerField(decl_idx)) |field| {
                    if (field.ast.value_expr == 0) {
                        const type_expr = gen.tree.nodes.get(field.ast.type_expr);
                        switch (type_expr.tag) {
                            .fn_proto_simple => {
                                try gen.fnProto(type_expr);
                                continue;
                            },
                            else => {
                                std.debug.print("{s}\n", .{@tagName(type_expr.tag)});
                            },
                        }
                    }
                }

                // If it wasn't consumed, just emit it directly.
                try std.fmt.format(gen.zig, "\n{s}\n", .{gen.tree.getNodeSource(decl_idx)});
            }
        }

        fn fnProto(
            gen: *@This(),
            type_expr: Ast.Node,
        ) !void {
            // TODO: need to pick out multiple parameters / call gen.externParam()
            //
            // const params = gen.tree.nodes.get(type_expr.data.lhs);
            // const return_type = gen.tree.nodes.get(type_expr.data.rhs);
            // std.debug.print("debug: params: {s}\n", .{@tagName(params.tag)});
            // std.debug.print("debug: return type: {s}\n", .{@tagName(return_type.tag)});

            // /// `fn(a: lhs) rhs`. lhs can be omitted.
            // /// anytype and ... parameters are omitted from the AST tree.
            // /// main_token is the `fn` keyword.
            // /// extern function declarations use this tag.
            // fn_proto_simple,
            // /// `fn(a: b, c: d) rhs`. `sub_range_list[lhs]`.
            // /// anytype and ... parameters are omitted from the AST tree.
            // /// main_token is the `fn` keyword.
            // /// extern function declarations use this tag.
            // fn_proto_multi,
            // /// `fn(a: b) rhs addrspace(e) linksection(f) callconv(g)`. `FnProtoOne[lhs]`.
            // /// zero or one parameters.
            // /// anytype and ... parameters are omitted from the AST tree.
            // /// main_token is the `fn` keyword.
            // /// extern function declarations use this tag.
            // fn_proto_one,
            // /// `fn(a: b, c: d) rhs addrspace(e) linksection(f) callconv(g)`. `FnProto[lhs]`.
            // /// anytype and ... parameters are omitted from the AST tree.
            // /// main_token is the `fn` keyword.
            // /// extern function declarations use this tag.
            // fn_proto,

            // Generate namespaced name (`extern fn sysjs_foo_bar_baz`)
            try std.fmt.format(gen.zig, "extern fn sysjs_", .{});
            for (gen.namespace.items) |ns| try std.fmt.format(gen.zig, "{s}_", .{ns});
            // try std.fmt.format(gen.zig, "{s}", .{name});
            try std.fmt.format(gen.zig, "(v0: {s})", .{gen.tree.getNodeSource(type_expr.data.lhs)});
            try std.fmt.format(gen.zig, " {s};\n", .{gen.tree.getNodeSource(type_expr.data.rhs)});
        }

        // TODO: write a function that emits parameters for functions, but in their 'extern' form.
        // e.g. expanding `[]const u8` to a pointer and length or such.
        // fn externParam
    };
}
